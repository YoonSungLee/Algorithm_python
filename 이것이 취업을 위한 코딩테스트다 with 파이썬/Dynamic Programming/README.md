# Dynamic Programming

---

# 1. 다이나믹 프로그래밍(동적 계획법) 의미
* 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘
* 이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 합니다.
* 메모리 공간을 약간 더 사용하여 연산 속도(수행 시간 효율성)를 비약적으로 증가시키는 방법
* 다이나믹(Dynamic): (일반적인 프로그래밍 분야에서)'프로그램이 실행되는 도중에'
    * ex) 자료구조에서 동적 할당(Dynamic Allocation): 프로그램 실행 중에 프로그램 실행에 필요한 메모리를 할당하는 기법
    * 다이나믹 프로그래밍에서의 '다이나믹'은 이런 의미는 아니다.
    
# 2. 피보나치 수열
* 점화식: 인접한 항들 사이의 관계식
* 프로그래밍에서는 수열을 배열이나 리스트로 표현 가능
    * 파이썬의 경우 기본 자료형인 리스트 자료형이 연결 리스트의 기능을 포함하고 있는 점이 다른 프로그래밍 언어에서의 배열과 차이점이다.
    
```python
# 피보나치 함수(Fibonacci Function)를 재귀 함수로 구현
# 시간 복잡도: O(2^n) (지수 시간 복잡도)

def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x - 1) + fibo(x - 2)

print(fibo(4))
```
* 위의 예시처럼 피보나치 수열의 점화식을 재귀 함수를 사용해 만들 수는 있지만, 단순히 매번 계산하도록 하면 문제를 효율적으로 해결할 수 없다. 이러한 문제는 다이나믹 프로그래밍을 사용하면 효율적으로 해결할 수 있다.

# 3. 다이나믹 프로그래밍
* 다이나믹 프로그래밍은 다음 조건을 만족할 때 사용할 수 있다.
    * 최적 부분 구조(Optimal Substructure): 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있습니다.
    * 중복되는 부분 문제(Overlapping Subproblem): 동일한 작은 문제를 반복적으로 해결해야 합니다. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.
* 메모이제이션(Memoization)
    * 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법을 의미한다.
    * 메모이제이션 값을 저장하는 방법이므로 캐싱(Caching)이라고도 한다.
    * 구현 방법: 한 번 구한 정보를 리스트에 저장한다. 다이나믹 프로그래밍을 재귀적으로 수행하다가 같은 정보가 필요할 때는 이미 구한 정답을 그대로 리스트에서 가져오면 된다.
    * 때에 따라서 배열, 리스트, 사전(dict) 자료형 이용 가능
    * 사전(dict) 자료형은 수열처럼 연속적이지 않은 경우에 유용 ex) a_n을 계산하고자 할 때 a_0 ~ a_(n-1) 모두가 아닌 일부의 작은 문제에 대한 해답만 필요한 경우, 사전 자료형을 사용하는 게 더 효과적이다.
    * 엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미합니다.
        * 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아닙니다.
        * 한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있습니다.
* 탑다운(Top-Down) 방식
    * 큰 문제를 해결하기 위해 작은 문제를 호출
    * 재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드 작성
    * 하향식
    * 메모이제이션: 탑다운 방식에 국한되어 사용하는 표현
* 보텀업(Bottom-Up) 방식
    * 작은 문제부터 차근차근 답을 도출
    * 반복문을 이용한 소스코드를 작성
    * 상향식
    * 다이나믹 프로그래밍의 전형적인 형태
    * DP 테이블: 보텀업 방식에서 사용되는 결과 저장용 리스트
* 다이나믹 프로그래밍의 시간 복잡도: O(N) --> 피보나치 수열 예시를 통해 추상적으로 증명해볼 것!
```python
# 시간 복잡도: O(N)
# 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수(Fibonacci Function)를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)
def fibo(x):
    # 종료 조건(1 혹은 2일 때 1을 반환)
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적 있는 문제라면 그대로 반환
    if d[x] != 0:
        return d[x]
    # 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]

print(fibo(99))
```
```python
# 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [0] * 100

# 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1
d[2] = 1
n = 99

# 피보나치 함수(Fibonacci Function) 반복문으로 구현(보텀업 다이나믹 프로그래밍)
for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])
```
# 4. 다이나믹 프로그래밍 vs 분할 정복
* 다이나믹 프로그래밍과 분할 정복은 모두 최적 부분 구조를 가질 때 사용할 수 있습니다.
    * 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황
* 다이나믹 프로그래밍과 분할 정복의 차이점은 부분 문제의 중복입니다.
    * 다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복됩니다.
    * 분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않습니다.


# 5. 코딩테스트 적용 시
* 일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제되는 경우가 많다.
* 주어진 문제가 다이나믹 프로그래밍 유형임을 파악해야 한다. 특정한 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 다이나믹 프로그래밍을 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인해보자.
* 가장 먼저 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토할 수 있다.
    * 다른 알고리즘으로 풀이 방법이 떠오르지 않으면 다이나믹 프로그래밍을 고려해 본다.
* 일단 단순히 재귀 함수로 비효율적인 프로그램을 작성한 뒤에 (탑다운) 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면, 즉 메모이제이션을 적용할 수 있으면 코드를 개선하는 방법도 좋은 아이디어다.
* 가능하다면 재귀 함수를 이용하는 탑다운 방식보다는 보텀업 방식으로 구현하는 것을 권장한다. 시스템상 재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문이다.
    * 'recusion depth'와 관련된 오류 발생 시, sys 라이브러리에 포함되어 있는 setrecursionlimit() 메서드를 호출하여 재귀 제한을 완화할 수 있다.

```python
# 파이썬 인터프리터 소스 코드(C 언어)에는 최대 재귀 깊이가 1,000으로 정의

import sys
sys.getrecursionlimit()     # 1000

sys.setrecursionlimit(2000)    # 최대 재귀호출 횟수를 2000으로 늘림
```